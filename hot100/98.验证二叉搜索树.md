# 98.验证二叉搜索树

## 题目描述
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
          示例 1:

          输入:
              2
             / \
            1   3
          输出: true
          示例 2:

          输入:
              5
             / \
            1   4
               / \
              3   6
          输出: false
          解释: 输入为: [5,1,4,null,null,3,6]。
               根节点的值为 5 ，但是其右子节点值为 4 。


## 解题思路
这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。

我们遍历每个根节点。1.如果是根节点，那么lower和upper是null，那么不需要判断。  2. 递归，根节点-->root.left，那么他的值要小于父节点，即参数upper=root.val。 3.递归，根节点-->root.right,那么他的值要要大于父节点


## 代码
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }

    public boolean helper(TreeNode root, Integer lower, Integer upper){
        if(root == null){
            return true;
        }

        int val = root.val;
        if(lower != null && lower>=val){
            return false;
        }
        if(upper != null && upper<=val){
            return false;
        }

        if(!helper(root.left, lower, val)){
            return false;
        }
        if(!helper(root.right, val, upper)){
            return false;
        }
        return true;
    }
}
```
