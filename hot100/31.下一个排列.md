# 31. 下一个排列

## 题目描述
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

 

      示例 1：

      输入：nums = [1,2,3]
      输出：[1,3,2]
      示例 2：

      输入：nums = [3,2,1]
      输出：[1,2,3]
      示例 3：

      输入：nums = [1,1,5]
      输出：[1,5,1]
      示例 4：

      输入：nums = [1]
      输出：[1]


## 解题思路
以排列 [4,5,2,6,3,1] 为例：

我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。

当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。

具体地，我们这样描述该算法，对于长度为 n 的排列 a：

首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。

如果找到了顺序对，那么在区间[i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为a[j]。

交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。


## 代码
```java
class Solution {
    public void nextPermutation(int[] nums) {
        int length = nums.length;
        int left = 0;           //（1）记录要交换的较小数，即从右边遍历第一个不是升序排列的数
        int rgiht = length-1;          //记录要交换的较大数，即从右边遍历第一个大于（1）中查找到的较小数
        for(int i=length-2; i>=0; i--){
            if(nums[i] < nums[i+1]){
                left = i;
                break;
            }
        }

        for(int i=length-1; i>=0; i--){
            if(nums[i] > nums[left]){
                rgiht = i;
                break;
            }
        }
        swap(nums,left,rgiht);
        Arrays.sort(nums, left+1, length);
    }

    public void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```
